1-1 Truffle 프로젝트 설정
대부분 스마트 컨트랙트를 사용할 때는 대부분 트러플 구조를 사용하고 있음
- contracts 폴더

- migrations 폴더
배포 관련 스크립트

- test 폴더
테스트 코드들 (솔리디티에서 짤수있는 테스트 - 자체 언어로만 만들어진 테스트 or js를 사용한 테스트 // 솔리디티만을 사용한 테스트보다는 js를 통해서하는 테스트가 주로 활성화)

- build 폴더 (컴파일이 완료될 경우 생성됨) -> 컴파일 한 결과들이 json파일 형식으로 생성됨
bytecode - 실제 블록체인 네트워크에 배포될 때 사용되는 바이트 코드
sourcemap - 
등 여러가지 메타정보들이 들어가 있음.
solidity를 truffle을 사용하지 않고 solc 컴파일러를 사용했을 경우에도 바이트 코드나 소스맵을 다 뽑을 수 있음
하지만 트러플 컴파일러는 이것들을 좀 사용하기 쉽게 미리 한번에 제공해주는 역할을 함.

truffle compile이 완료되면 truffle-config.js 파일이 생성됨
smart contract를 한번 배포한 다음 다시 한번 배포하려는 경우 그냥 truffle migrate를 쓰는 것이 아니라
truffle migrate --reset을 써주어야 함

2-1 dapp 서비스 설계
    1. 지갑관리
        일반 유저 뿐만 아니라 스마트 컨트랙트를 관리하는 사람.
        스마트 컨트랙트의 특정 함수에 권한이 있어서 그 함수들을 어떻게 관리할 건지 또 어떤 사람이 어떤 함수에 접근이 가능한지,
        어떤 컨트랙트는 다른 어떤 컨트랙트에 접근이 가능하게 할건지
        그리고 특정 주소에 대해서 이 주소를 가지고 있는 키를 하드월렛에서 관리하는지 인터넷에 연결되어 있지 않은 곳에서 관리하겠다 또는 인터넷에 연결되어있는 곳에서 관리하겠다.
        만약에 인터넷에 연결되어있다면 보안이 불안할 수 있음 그럴 경우 하드월렛에 있는 돈이 부족할 때는 어떤 식으로 알림을 노티를 받아서 콜드월렛에서 돈을 받아오겠다 이런 식의 관리 방법이 필요함
        또 돈이 많이 쌓였을 때는 하나의 개인키에 돈을 보관하는 것은 보안상 굉장히 불안할 수 있음 
        이때는 멀티시그월렛을 생각해 볼 수 있음.
        * 멀티시그월렛 이란?
            키를 하나만 가지고 관리하는 것이 아니라 스마트 컨트랙트 기반으로 two of three 3명 중 2명이 오케이 했을 때만 돈을 보내고 바꿀 수 있는 지갑을 말함
        가장 중요한 것이 지갑관리가 될 것 
    
    2. 아키텍쳐
        기존의 서비스들 같은 경우에는 sever - client 구조로 동일한데 디앱서비스 같은 경우에는 한개가 더 들어온 것(블록체인)
        단순하게 웹서비스를 하려고 해도 웹 서버가 필요함 ipfs 같은 decentralized storage (분산저장소)를 사용할 수도 있음
        스마트 컨트랙트만을 사용했을 때에는 모든 데이터를 스마트 컨트랙트 상에서 관리해야되기 때문에 유연하게 대처하기 어려움 
        하지만 스마트 컨트랙트와 서버를 같이 사용할 경우에는 중요한 데이터는 스마트 컨트랙트에서 관리하고 덜 중요한 데이터는 서버에서 관리하는 등 여러가지 서비스를 다채롭게 구성할 수 있음.
        a. smart contract - front
        b. smart contract - server - front
    
    3. code
        a. 코드를 실행하는데 돈이 든다.
            스마트 컨트랙트는 디도스 공격을 막기 위해서 코드를 실행하는데 돈이 들게 만들어놨음
            그래서 단순하게 +1 하는 연산을 하더라도 돈이 들어가고 반복문이라던지 연산이 많이 드는 행동을 할 경우 모두 돈이 들어간다는 것을 주의 깊게 생각하고 있어야 함 
        b. 권한 관리
            스마트 컨트랙트가 하나이고 함수가 몇개 안되면 큰 문제가 안되지만 비니지스 로직이 좀 더 복잡해지다보면 중요한 함수에 접근할 수 있는 권한을 관리하고 권한이 수정되었을 때 권한을 어떻게 삭제할 것인지 이런 방법들을 어떻게 핸들링 할 것인지를 미리 생각하는 게 중요함 
        c. 비즈니스 로직 업데이트
            비즈니스 로직이라는게 처음에 한 번 정해지고 그 이후에 계속 픽스된 상태로 가기는 힘듬
            어떻게 변경할 건지에 대한 생각을 계속 해야 함. 
            스마트 컨트랙트의 가장 큰 단점으로 나오는 게 항상 업데이트 관련 부분임
            제안된 방법으로 delegatecall를 한다던지 컨트랙트를 바꿔치기 한다던지 하는 방법으로 하고 있는데
            이걸 어떻게 할 건지에 대해서 항상 미리 고민하는게 중요함 
        d. 데이터 마이그레이션
            데이터에 스마트 컨트랙트에 저장을 했는데 그 데이터를 다른 스마트 컨트랙트로 옮기는 경우. 
            미리 저장된 데이터를 어떻게 옮길 것인가 하는 고민을 미리 해야 함
            저장소용 스마트 컨트랙트를 만들고 비즈니스 용 컨트롤러 컨트랙트를 만들어서 분리하는 방법 등 여러가지 방법이 많이 있지만 기본적으로 항상 생각을 해놓고 있어야 함 
            보통 erc20 토큰 컨트랙트에서 많이 사용하는 것 중 하나는 프리즈를 시키고 자기네 메인넷에 다 옮겨 놓던지 아니면 실제 메인으로 사용할 토큰 컨트랙트로 옮겨놓던지 하는 방법이 있음
    4. 운영 
        실제 서비스에 들어갈 때 운영을 어떻게 할 것인가에 대한 것 (운영에는 테스트도 포함되고 메인 서비스도 포함됨)
        우리가 사용할 네트워크가 퍼블릭 네트워크 일 수도 있고 프라이빗 네트워크 일 수도 있음 
        그리고 퍼블릭 쪽에서도 테스트넷, 메인넷 이렇게 운영이 될 텐데 처음에는 테스트넷에서 배포를 한 번 해보고 메인넷으로 갈텐데
        이때 어떻게 쉽게 배포를 하고 테스트를 하고 관리를 할건지
        프라이빗 네트워크에 배포를 한다면 프라이빗 네트워크를 어떻게 세팅하고 어떻게 관리를 할건지 
        또 합의 방법. poa처럼 돌아가면서 합의를 본다던지 아니면 똑같이 pow 하겠다던지 여러가지 방법이 있을 텐데 이걸 어떻게 진행할 것인지에 대한 생각을 미리 하는게 중요  
        a. public
        b. private

2-2 Lottery 규칙
    1. +3번째 블록해쉬의 첫 두글자 맞추기 '0xab......'
        a. 유저가 던진 트랜젝션이 들어가는 블록 + 3 의 블록해쉬와 값을 비교
    2. 팟머니
        a. 결과가 나왔을 때만 유저가 보낸 돈을 팟머니에 쌓기
        b. 여러 명이 맞췄을 때는 가장 먼저 맞춘 사람이 팟머니를 가져가기
        c. 두 글자 중 하나만 맞췄을 때는 보낸 돈을 돌려줌 0.005ETH : 10 ** 15 wei
        d. 결과 값을 검증할 수 없을 때에는 보낸 돈을 돌려줌
    
    스마트 컨트랙트에서는 스마트 컨트랙트 안에서 내 현재 트랜잭션이 몇 번째 블락에 들어가는 상황인지 값을 얻어올 수 있음 
    그리고 그 전 블락까지의 블록해쉬 값도 가져올 수 있음 
    그런데 예를 들어서 내가 3번 블락에 내 트랜잭션이 들어가고 있고 연산하고 있는 상황이라면(3번 블락이 만들어지고 있는 상황이라면) 3번 블록의 블록해쉬값을 얻어올 수 없음
    블록체인에서 블럭이 만들어질 때는 스마트 컨트랙트 트랜잭션이 차례대로 쌓이고 그 차례대로 쌓인 트랜잭션이 하나의 블락으로 형성이 되는데 
    3번 블락안에 들어가는 트랜잭션은 3번 블락안의 해쉬값을 알 수 없음
    그래서 6번 블락의 블록해쉬값을 알 수 있는 상황은 7번 블락이 만들어질 때임 
    그래서 내가 3번 블럭에 들어가는 배팅 트랜잭션이 6번 블락의 블록해쉬값을 맞추기 게임을 했다라고 하면 
    그 결과는 7번이상의 블락에서 확인을 할 수 있음.
    스마트 컨트랙트 안에서 확인할 수 있는 블록해쉬값은 최근 256블락까지만 확인할 수 있음 
    그래서 예를 들어 280번이다 하면 280 - 256 하면 24번. 그러면 5번 이후의 블락부터만 블록해쉬를 확인할 수 있음
    그래서 블록해쉬값을 확인할 수 없는 경우에는 결과를 검증할 수 없기 때문에 받은 돈을 돌려줌 